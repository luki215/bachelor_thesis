\chapter{Testing}
In the following chapter, we describe the process of testing the application. 

Each feature and request has been tested by us after the implementation. Then we published the feature to front-end. Naturally, during the implementation they tested the feature again.

In our application we evaluated two critical parts to which we decided adding the third layer of testing. First is the user authentication and manipulation part. Second is the order scheduler. For these features we followed the \textit{Test-driven development}\footnote{\url{https://en.wikipedia.org/wiki/Test-driven_development}} software development process. When all of the tests for the given feature have passed we continued testing the feature such as in the other parts of the application.

For the user part of the application we used integration tests. From our experience, the part of the application responsible for the user creation and activation is not used by the front-end developers on a regular basis thus we lose the front-end check insurance part. On top of that, the user registration and activation process is the most crucial part of the business. When there occurs error during the registration, it is likely that the user will never use our application again.  

The motivation to cover the scheduler system by unit tests was different. First of all, we started by analysis of the possible situations. During the development, we discovered more and more edge-cases and by fixing them we started to breaking other parts. Also reproducing all the edge cases took a lot of time. Besides that, we use the Google Maps API for the route calculation. This gives even for the same two points different time estimations based on current time and traffic. In the end, we decided to mock the API and write a set of tests covering all of the possible situations from the solution design ensuring the desired outputs. Based on these tests we started to implement the scheduler. 
 

\section{Technologies used for testing}

Ruby on Rails has a variety of libraries which make the testing easy. As the testing library core we decided to use the \textit{RSpec}\footnote{\url{http://rspec.info/}}. This library has an intuitive interface, helpful features and is kind of standard in the Ruby on Rails world.

Next essential part of our testing stack is  the \textit{factory\_bot} gem\footnote{\url{https://github.com/thoughtbot/factory_bot}}. In short, this library allows us to define multiple factories for each model in the application. When we need an instance of a model, we just use the library's factory and it will return the model instance with the data fields corresponding to the factory definition. It also allows us to specify relations between the factories so that we can easily get for example instance of the user with three orders. As random data generator for these factories, we use the gem \textit{faker}, which helps us with generating realistic looking random data.