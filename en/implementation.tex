\chapter{Implementation}
Implementation chapter describes the application architecture and project file structure. Then we focus on implementation details of the most important parts and how are they solved.

Ruby on Rails framework is tightly connected with the Convention over configuration software design paradigm. In short that means that we as a programmer are forced to use Rails conventions otherwise it will not work. This implies that the whole project file structure or class naming conventions are strictly given. 

Most of the application is solved using these conventions and tools that the framework gives us. In next section we are going to describe them. If you are already familiar with Ruby on Rails framework, you are free to skip next section and explore the source code.

\section {Project architecture}
	Ruby on Rails is MVC framework. We suppose, that the reader is familiar with the MVC \todo{source} pattern.
	
	Whole Rails application lays in \textit{TaxiBackendApp} folder. In following chapter we are going to describe all of the key files and folders that we are using in our project. All the other files and folders which are not described in this section can be ignored - they are either automatically generated by the framework or we didn't needed that feature of the framework during the development.
	
	These are the key folders and files in our project: 
	\begin{itemize}
		\item app
			\begin{itemize}
				\item controllers
				\item helpers
				\item lib
				\item mailers
				\item models
				\item policies
				\item uploaders
				\item validators
				\item views
				\item workers
			\end{itemize}
		\item config \begin{itemize}
			\item environments
			\item initializers
			\item locales
			\item application.rb
			\item database.yml
			\item routes.rb
			\item sidekiq.yml
		\end{itemize}
		\item db \begin{itemize}
			\item migrate
			\item seeds.rb
			\item schema.rb
		\end{itemize}
		\item lib
		\item public
		\item spec \begin{itemize}
			\item factories
			\item requests
		\end{itemize}
		\item Gemfile
	\end{itemize}

	\subsection{app/controllers}
		In this folder are placed all the controllers we use in the application. All of the controllers in Ruby on Rails must inherit from the \textit{ApplicationController}. Because we are writing API which may have next versions in the future, we decided to add one more layer - \textit{ApiV2Controller} which takes care about the API-specific general tasks such as authorization. This implies that all the controllers for our API are inherited from this controller.
		
		Each controller is separate file in which is just one - the controller class.
		
		Each public method in the controller class is considered as action which can be binded to the router. Default actions are:
		\begin{itemize}
			\item index = display all entities
			\item show = show specific entity
			\item create
			\item update
			\item destroy		
		\end{itemize} 
	
		Best practice is to fit with most of the actions on the entities in these names. For action show, update and destroy we suppose that we get entity id from the router.
		  \todo{p≈ôidat odkaz na rails guides pro kontrolery}
	\subsection{app/helpers}
		This folder contains helpers for the application. Helpers are specific functions which are more general for the application and we want to have them separated for better code readability. 
		
		In our application was the helpers folder the first choice where to put the calculation of the distance between the two coordinates, because we use it in both controllers and workers and it is quite complex function to have it directly in place.
	\subsection{app/lib}
		This folder is usually the folder where you place everything which can not be classified to one of the default Ruby on Rails framework predefined folders. Usually it is the code containing custom logic related to the problem the application is solving.
		
		In our case this folder contains whole orders scheduler including the Google Matrix API wrapper.
		
	\subsection{app/mailers}
		Ruby on Rails has built-in support for sending emails. For each entity we can create class called Mailer, which can have multiple methods - specific emails and its configurations, based on which the email is later sent. Using this mailer provides us out-of-the box asynchronous queue sending via SMTP - configured in \textit{config/initializers} folder.
		 
		 The mail template which will be used for the email is specified in the \textit{views/entity\_mailer/action\_mail.*}.
		 
		 In our application we used these mailers for the employees registration and forgotten password mails.
	\subsection{app/models}
		
	\subsection{app/policies}
	\subsection{app/uploaders}
	\subsection{app/validators}
	\subsection{app/views}
	\subsection{app/workers}
	\subsection{config/environments}
	\subsection{config/initializers}
	\subsection{config/locales}
	\subsection{config/application.rb}
	\subsection{config/database.yml}
	\subsection{config/routes.rb}
	\subsection{config/sidekiq.yml}
	\subsection{db/migrate}
	\subsection{db/seeds.rb}
	\subsection{db/schema.rb}
	\subsection{lib}
	\subsection{public}
	\subsection{spec/factories}
	\subsection{spec/requests}
	\subsection{Gemfile}

\section {Specific implementation details}
\subsection {Authentication}
We created concern \textit{AuthenticableUser} which is included in both Customer and Employees model. The concern takes care of auth token generation and manipulation using \textit{has\_secure\_token} \footnote{\url{https://api.rubyonrails.org/classes/ActiveRecord/SecureToken/ClassMethods.html}} Rails utility. 

\textit{ApiV2Controller} is the one responsible for checking auth token in headers and setting the current user variable for all the controllers.

SMS workers now just print tokens to logs. When we go to production we just sent this token to some third-party SMS gateway API.

Mailer used for employees token sending is not connected to mail server. All the mails now goes Mailtrap\footnote{\url{https://mailtrap.io/}}, which is a fake SMTP server. In production we must switch to real one. Once we have them, just change the \textit{config/environments/production.rb} config.action\_mailer section

\subsection {Authorization}
We use \textit{Pundit} gem to help us with authorization. For each controller in \textit{api/v2} there is one permissions definition file in \textit{politions} folder with the according name.  This file contains policy class. 

Each method in this policy class is permission definition for the corresponding action in controller. There could also be scope definitions. Their purpose is to return subset of the current entities to which has current user access to. Last type of methods that can appear in these files are custom policy definition methods. These methods check other specific actions needed somewhere in the application and they are called explicitly from views or controllers.

The whole Pundit initialization is in \textit{api/v2/api\_v2\_controller.rb} where is also defined what the application should do if the request is unauthorized. As we can see, our implementation returns error 403 with 'not authorized' error as specified.

In each controller action we must call the \textit{authorize} method which will automatically checks the permissions for us. If we don't want to authorize the request we must explicitly call \textit{skip\_authorization}. In case we don't call it, there will be raised missing authorization exception on such endpoint. This mechanism is there to prevent the situation when programmer forgets to set authorization for the endpoint, which would lead to possible sensitive data exposure.

\section {Customers}
\subsection{Create}
We ended with three endpoints: create, confirm and resend confirmation. 

\subsection{Customer favourite location}

\section {Employees}
how email links are stored in env variables
